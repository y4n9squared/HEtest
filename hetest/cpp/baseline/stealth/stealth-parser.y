/***************************************************************
* Copyright MIT Lincoln Laboratory
* Project:       SPAR
* Authors:       Yang
* Description:   Parser grammar file for Stealth circuits
*
* Modifications
* Date         Name             Modification
* ----         ----             ------------
* 25 July 2012 Yang             Original Version
* 09 Aug 2012  Yang             Default token type is now
                                YYSTYPE intead of Token.
***************************************************************/
 
/*
This file defines the grammar for the Stealth circuit parser.
The parser reads in a series of tokens generated by the scanner
and incrementally builds a circuit.
*/

/*
The include directive tells lemon to include the following code
directly at the beginning of the source code. Here, we need to
include some standard libraries and the circuit definitions.
 
stealth-def.h contains some structures used by the parser to 
pass information.
*/
%include {
/* needed for free() */
#include <cstdlib>
/* required by leomon */
#include <cassert>
#include <map>
#include <vector>
#include <string>

/* Each gate will be wrapped in a shared pointer for memory management */
#include <boost/shared_ptr.hpp> 

/* This will be build from a subdirectory (debug for debug builds, opt
   for release builds, etc.) so all include paths are relative to that. */
#include "baseline/common/lex-global.h"
#include "stealth-parser.h"
#include "baseline/stealth/stealth-def.h"
#include "baseline/stealth/stealth-circuit-gates.h"
#include "common/logging.h"
#include "common/check.h"

// A vector containing Wire gates that represent circuit wires
std::vector<WirePtr>* wires;
   
// A map used to track gates and their label names during parsing
std::map<std::string, MultiGatePtr> gates;

// A helper function that adds already defined gates as inputs to newly
// created gates. The first argument is a pointer to a new gate. The
// second argument is a pointer to a vector of InputTokens, which contain
// information about input gates.
void AddInputsFromTokens(
   MultiInputGate* gate, std::vector<InputToken>* input_ptr) {
  std::vector<InputToken>& inputs = *input_ptr;
  for (unsigned int i = 0; i < inputs.size(); ++i) {
    if (inputs[i].type == LABEL) {
      DCHECK(gates.find(inputs[i].label_name) != gates.end());
      // The input gate is already defined since it's a LABEL
      if (inputs[i].is_negated) {
        GatePtr not_gate(new Not(gates[inputs[i].label_name]));
        gate->AddInput(not_gate);
      } else {
        gate->AddInput(gates[inputs[i].label_name]);
      }
      free((void*)inputs[i].label_name);
    } else {
      // The input gate which needs to be added is a WIRE
      if (inputs[i].is_negated) {
        GatePtr not_gate(new Not((*wires)[inputs[i].wire_num]));
        gate->AddInput(not_gate);
      } else {
        gate->AddInput((*wires)[inputs[i].wire_num]);
      }
    }
  }
  // input_ptr was heap-allocated in a previous rule. Since
  // we extracted all its information, de-allocate it.
  delete input_ptr;
}
}

/* the %extra_argument directive specifies the type of the 4th
argument of Parse(...) which can be used to pass information
out of the parser. the data are heap-allocated and need to be 
de-allocated by the caller */
%extra_argument{ParserState* parser_state}

/* the %token_type directive specifies the type of the terminal
symbols. This is the 3rd parameter of Parse(...). */
%token_type {YYSTYPE}

/* the %type directive specifies the type of non-terminal symbols.
They are structures defined in stealth-def.h. */
%type input {InputToken}
%type inputs {InputsToken}
%type gate {GateToken}

/* the %parse_accept directive takes code, which is executed
when all tokens have been successfully accepted. By this time
our circuit is complete and we can set the head and wire
pointers and exit. */
%parse_accept {
  DCHECK(gates.count("output_gate") == 1);
  parser_state->output_gate = gates["output_gate"];
  parser_state->wires = wires;
}

/* the %syntax_error directive executes the following code
if an invalid sequence of tokens is detected. */
%syntax_error {
  LOG(FATAL) << "Error parsing circuit";
}

/* Grammar rules start here. program is the start symbol. */
program ::= circuit .
circuit ::= headers gate_defs.

headers ::= headers header .
headers ::= header .

/* when we find the information "W=10", we can create 10 new
Wire gates as the inputs to the circuit */ 
header ::= NUM_INPUTS(B) . {
  wires = new std::vector<WirePtr>();
  wires->reserve(B.int_val);
  for (int i = 0; i < B.int_val; ++i) {
    wires->push_back(boost::shared_ptr<Wire>(new Wire()));
  }
  DCHECK(wires->size() == static_cast<unsigned int>(B.int_val));
}

/* a list of gate definitions is a series of one or more
gate definitions */ 
gate_defs ::= gate_defs gate_def .
gate_defs ::= gate_def .

/* a gate definition consists of a label, colon, and gate */
gate_def ::= LABEL(B) COLON gate(C) . {
  MultiGatePtr gate(C.gate);
  gates[B.str_val] = gate;
  free((void*)B.str_val);
}

/* a gate definition consists of an output label, colon and gate */
gate_def ::= OUTPUT COLON gate(B) . {
  MultiGatePtr gate(B.gate);
  gates["output_gate"] = gate;
}

/* a gate consists of a gate type and inputs enclosed by parentheses */
gate(A) ::= AND LPAREN inputs(B) RPAREN. {
  A.gate = new And();
  AddInputsFromTokens(A.gate, B.inputs);
}
gate(A) ::= OR LPAREN inputs(B) RPAREN . {
  A.gate = new Or();
  AddInputsFromTokens(A.gate, B.inputs);
}
gate(A) ::= XOR LPAREN inputs(B) RPAREN . {
  A.gate = new Xor();
  AddInputsFromTokens(A.gate, B.inputs);
}

/* a list of inputs contains one or more possibly negated inputs */
inputs(A) ::= inputs(B) input(C) . {
  C.is_negated = false;
  B.inputs->push_back(C);
  A.inputs = B.inputs;
}
inputs(A) ::= inputs(B) NOT LPAREN input(C) RPAREN . {
  C.is_negated = true;
  B.inputs->push_back(C);
  A.inputs = B.inputs;
}
inputs(A) ::= . {
  A.inputs = new std::vector<InputToken>();
}

/* an input is a label or wire */
input(A) ::= LABEL(B) . {
  A.type = LABEL;
  A.label_name = B.str_val;
}
input(A) ::= WIRE(B) . {
  A.type = WIRE;
  A.wire_num = B.int_val;
}

